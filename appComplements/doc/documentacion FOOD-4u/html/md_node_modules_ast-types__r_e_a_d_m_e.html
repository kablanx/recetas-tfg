<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Food4uDoc: AST Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="1_efuIMAmjzSpn9p7WalC6fA.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Food4uDoc
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_node_modules_ast-types__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">AST Types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This module provides an efficient, modular, <a href="https://github.com/ariya/esprima">Esprima</a>-compatible implementation of the <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> type hierarchy pioneered by the <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Mozilla Parser API</a>.</p>
<p><a href="https://travis-ci.org/benjamn/ast-types"><img src="https://travis-ci.org/benjamn/ast-types.png?branch=master" alt="Build Status" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md1369"></a>
Installation</h1>
<p>From NPM: </p><pre class="fragment">npm install ast-types
</pre><p>From GitHub: </p><pre class="fragment">cd path/to/node_modules
git clone git://github.com/benjamn/ast-types.git
cd ast-types
npm install .
</pre><h1><a class="anchor" id="autotoc_md1370"></a>
Basic Usage</h1>
<div class="fragment"><div class="line">var assert = require(&quot;assert&quot;);</div>
<div class="line">var n = require(&quot;ast-types&quot;).namedTypes;</div>
<div class="line">var b = require(&quot;ast-types&quot;).builders;</div>
<div class="line"> </div>
<div class="line">var fooId = b.identifier(&quot;foo&quot;);</div>
<div class="line">var ifFoo = b.ifStatement(fooId, b.blockStatement([</div>
<div class="line">    b.expressionStatement(b.callExpression(fooId, []))</div>
<div class="line">]));</div>
<div class="line"> </div>
<div class="line">assert.ok(n.IfStatement.check(ifFoo));</div>
<div class="line">assert.ok(n.Statement.check(ifFoo));</div>
<div class="line">assert.ok(n.Node.check(ifFoo));</div>
<div class="line"> </div>
<div class="line">assert.ok(n.BlockStatement.check(ifFoo.consequent));</div>
<div class="line">assert.strictEqual(</div>
<div class="line">    ifFoo.consequent.body[0].expression.arguments.length,</div>
<div class="line">    0);</div>
<div class="line"> </div>
<div class="line">assert.strictEqual(ifFoo.test, fooId);</div>
<div class="line">assert.ok(n.Expression.check(ifFoo.test));</div>
<div class="line">assert.ok(n.Identifier.check(ifFoo.test));</div>
<div class="line">assert.ok(!n.Statement.check(ifFoo.test));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1371"></a>
AST Traversal</h1>
<p>Because it understands the AST type system so thoroughly, this library is able to provide excellent node iteration and traversal mechanisms.</p>
<p>If you want complete control over the traversal, and all you need is a way of enumerating the known fields of your AST nodes and getting their values, you may be interested in the primitives <code>getFieldNames</code> and <code>getFieldValue</code>: </p><div class="fragment"><div class="line">var types = require(&quot;ast-types&quot;);</div>
<div class="line">var partialFunExpr = { type: &quot;FunctionExpression&quot; };</div>
<div class="line"> </div>
<div class="line">// Even though partialFunExpr doesn&#39;t actually contain all the fields that</div>
<div class="line">// are expected for a FunctionExpression, types.getFieldNames knows:</div>
<div class="line">console.log(types.getFieldNames(partialFunExpr));</div>
<div class="line">// [ &#39;type&#39;, &#39;id&#39;, &#39;params&#39;, &#39;body&#39;, &#39;generator&#39;, &#39;expression&#39;,</div>
<div class="line">//   &#39;defaults&#39;, &#39;rest&#39;, &#39;async&#39; ]</div>
<div class="line"> </div>
<div class="line">// For fields that have default values, types.getFieldValue will return</div>
<div class="line">// the default if the field is not actually defined.</div>
<div class="line">console.log(types.getFieldValue(partialFunExpr, &quot;generator&quot;));</div>
<div class="line">// false</div>
</div><!-- fragment --><p>Two more low-level helper functions, <code>eachField</code> and <code>someField</code>, are defined in terms of <code>getFieldNames</code> and <code>getFieldValue</code>: </p><div class="fragment"><div class="line">// Iterate over all defined fields of an object, including those missing</div>
<div class="line">// or undefined, passing each field name and effective value (as returned</div>
<div class="line">// by getFieldValue) to the callback. If the object has no corresponding</div>
<div class="line">// Def, the callback will never be called.</div>
<div class="line">exports.eachField = function(object, callback, context) {</div>
<div class="line">    getFieldNames(object).forEach(function(name) {</div>
<div class="line">        callback.call(this, name, getFieldValue(object, name));</div>
<div class="line">    }, context);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Similar to eachField, except that iteration stops as soon as the</div>
<div class="line">// callback returns a truthy value. Like Array.prototype.some, the final</div>
<div class="line">// result is either true or false to indicates whether the callback</div>
<div class="line">// returned true for any element or not.</div>
<div class="line">exports.someField = function(object, callback, context) {</div>
<div class="line">    return getFieldNames(object).some(function(name) {</div>
<div class="line">        return callback.call(this, name, getFieldValue(object, name));</div>
<div class="line">    }, context);</div>
<div class="line">};</div>
</div><!-- fragment --><p>So here's how you might make a copy of an AST node: </p><div class="fragment"><div class="line">var copy = {};</div>
<div class="line">require(&quot;ast-types&quot;).eachField(node, function(name, value) {</div>
<div class="line">    // Note that undefined fields will be visited too, according to</div>
<div class="line">    // the rules associated with node.type, and default field values</div>
<div class="line">    // will be substituted if appropriate.</div>
<div class="line">    copy[name] = value;</div>
<div class="line">})</div>
</div><!-- fragment --><p>But that's not all! You can also easily visit entire syntax trees using the powerful <code>types.visit</code> abstraction.</p>
<p>Here's a trivial example of how you might assert that <code>arguments.callee</code> is never used in <code>ast</code>: </p><div class="fragment"><div class="line">var assert = require(&quot;assert&quot;);</div>
<div class="line">var types = require(&quot;ast-types&quot;);</div>
<div class="line">var n = types.namedTypes;</div>
<div class="line"> </div>
<div class="line">types.visit(ast, {</div>
<div class="line">    // This method will be called for any node with .type &quot;MemberExpression&quot;:</div>
<div class="line">    visitMemberExpression: function(path) {</div>
<div class="line">        // Visitor methods receive a single argument, a NodePath object</div>
<div class="line">        // wrapping the node of interest.</div>
<div class="line">        var node = path.node;</div>
<div class="line"> </div>
<div class="line">        if (n.Identifier.check(node.object) &amp;&amp;</div>
<div class="line">            node.object.name === &quot;arguments&quot; &amp;&amp;</div>
<div class="line">            n.Identifier.check(node.property)) {</div>
<div class="line">            assert.notStrictEqual(node.property.name, &quot;callee&quot;);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        // It&#39;s your responsibility to call this.traverse with some</div>
<div class="line">        // NodePath object (usually the one passed into the visitor</div>
<div class="line">        // method) before the visitor method returns, or return false to</div>
<div class="line">        // indicate that the traversal need not continue any further down</div>
<div class="line">        // this subtree.</div>
<div class="line">        this.traverse(path);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Here's a slightly more involved example of transforming <code>...rest</code> parameters into browser-runnable ES5 JavaScript:</p>
<div class="fragment"><div class="line">var b = types.builders;</div>
<div class="line"> </div>
<div class="line">// Reuse the same AST structure for Array.prototype.slice.call.</div>
<div class="line">var sliceExpr = b.memberExpression(</div>
<div class="line">    b.memberExpression(</div>
<div class="line">        b.memberExpression(</div>
<div class="line">            b.identifier(&quot;Array&quot;),</div>
<div class="line">            b.identifier(&quot;prototype&quot;),</div>
<div class="line">            false</div>
<div class="line">        ),</div>
<div class="line">        b.identifier(&quot;slice&quot;),</div>
<div class="line">        false</div>
<div class="line">    ),</div>
<div class="line">    b.identifier(&quot;call&quot;),</div>
<div class="line">    false</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">types.visit(ast, {</div>
<div class="line">    // This method will be called for any node whose type is a subtype of</div>
<div class="line">    // Function (e.g., FunctionDeclaration, FunctionExpression, and</div>
<div class="line">    // ArrowFunctionExpression). Note that types.visit precomputes a</div>
<div class="line">    // lookup table from every known type to the appropriate visitor</div>
<div class="line">    // method to call for nodes of that type, so the dispatch takes</div>
<div class="line">    // constant time.</div>
<div class="line">    visitFunction: function(path) {</div>
<div class="line">        // Visitor methods receive a single argument, a NodePath object</div>
<div class="line">        // wrapping the node of interest.</div>
<div class="line">        var node = path.node;</div>
<div class="line"> </div>
<div class="line">        // It&#39;s your responsibility to call this.traverse with some</div>
<div class="line">        // NodePath object (usually the one passed into the visitor</div>
<div class="line">        // method) before the visitor method returns, or return false to</div>
<div class="line">        // indicate that the traversal need not continue any further down</div>
<div class="line">        // this subtree. An assertion will fail if you forget, which is</div>
<div class="line">        // awesome, because it means you will never again make the</div>
<div class="line">        // disastrous mistake of forgetting to traverse a subtree. Also</div>
<div class="line">        // cool: because you can call this method at any point in the</div>
<div class="line">        // visitor method, it&#39;s up to you whether your traversal is</div>
<div class="line">        // pre-order, post-order, or both!</div>
<div class="line">        this.traverse(path);</div>
<div class="line"> </div>
<div class="line">        // This traversal is only concerned with Function nodes that have</div>
<div class="line">        // rest parameters.</div>
<div class="line">        if (!node.rest) {</div>
<div class="line">            return;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        // For the purposes of this example, we won&#39;t worry about functions</div>
<div class="line">        // with Expression bodies.</div>
<div class="line">        n.BlockStatement.assert(node.body);</div>
<div class="line"> </div>
<div class="line">        // Use types.builders to build a variable declaration of the form</div>
<div class="line">        //</div>
<div class="line">        //   var rest = Array.prototype.slice.call(arguments, n);</div>
<div class="line">        //</div>
<div class="line">        // where `rest` is the name of the rest parameter, and `n` is a</div>
<div class="line">        // numeric literal specifying the number of named parameters the</div>
<div class="line">        // function takes.</div>
<div class="line">        var restVarDecl = b.variableDeclaration(&quot;var&quot;, [</div>
<div class="line">            b.variableDeclarator(</div>
<div class="line">                node.rest,</div>
<div class="line">                b.callExpression(sliceExpr, [</div>
<div class="line">                    b.identifier(&quot;arguments&quot;),</div>
<div class="line">                    b.literal(node.params.length)</div>
<div class="line">                ])</div>
<div class="line">            )</div>
<div class="line">        ]);</div>
<div class="line"> </div>
<div class="line">        // Similar to doing node.body.body.unshift(restVarDecl), except</div>
<div class="line">        // that the other NodePath objects wrapping body statements will</div>
<div class="line">        // have their indexes updated to accommodate the new statement.</div>
<div class="line">        path.get(&quot;body&quot;, &quot;body&quot;).unshift(restVarDecl);</div>
<div class="line"> </div>
<div class="line">        // Nullify node.rest now that we have simulated the behavior of</div>
<div class="line">        // the rest parameter using ordinary JavaScript.</div>
<div class="line">        path.get(&quot;rest&quot;).replace(null);</div>
<div class="line"> </div>
<div class="line">        // There&#39;s nothing wrong with doing node.rest = null, but I wanted</div>
<div class="line">        // to point out that the above statement has the same effect.</div>
<div class="line">        assert.strictEqual(node.rest, null);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Here's how you might use <code>types.visit</code> to implement a function that determines if a given function node refers to <code>this</code>:</p>
<p>```js function usesThis(funcNode) { n.Function.assert(funcNode); var result = false;</p>
<p>types.visit(funcNode, { visitThisExpression: function(path) { result = true;</p>
<p>// The quickest way to terminate the traversal is to call // this.abort(), which throws a special exception (instanceof // this.AbortRequest) that will be caught in the top-level // types.visit method, so you don't have to worry about // catching the exception yourself. this.abort(); },</p>
<p>visitFunction: function(path) { // ThisExpression nodes in nested scopes don't count as <code>this</code> // references for the original function node, so we can safely // avoid traversing this subtree. return false; },</p>
<p>visitCallExpression: function(path) { var node = path.node;</p>
<p>// If the function contains CallExpression nodes involving // super, those expressions will implicitly depend on the // value of <code>this</code>, even though they do not explicitly contain // any ThisExpression nodes. if (this.isSuperCallExpression(node)) { result = true; this.abort(); // Throws AbortRequest exception. }</p>
<p>this.traverse(path); },</p>
<p>// Yes, you can define arbitrary helper methods. isSuperCallExpression: function(callExpr) { n.CallExpression.assert(callExpr); return this.isSuperIdentifier(callExpr.callee) || this.isSuperMemberExpression(callExpr.callee); },</p>
<p>// And even helper helper methods! isSuperIdentifier: function(node) { return n.Identifier.check(node.callee) &amp;&amp; node.callee.name === "super"; },</p>
<p>isSuperMemberExpression: function(node) { return n.MemberExpression.check(node.callee) &amp;&amp; n.Identifier.check(node.callee.object) &amp;&amp; node.callee.object.name === "super"; } });</p>
<p>return result; } ```</p>
<p>As you might guess, when an <code>AbortRequest</code> is thrown from a subtree, the exception will propagate from the corresponding calls to <code>this.traverse</code> in the ancestor visitor methods. If you decide you want to cancel the request, simply catch the exception and call its <code>.cancel()</code> method. The rest of the subtree beneath the <code>try</code>-<code>catch</code> block will be abandoned, but the remaining siblings of the ancestor node will still be visited.</p>
<h1><a class="anchor" id="autotoc_md1372"></a>
NodePath</h1>
<p>The <code>NodePath</code> object passed to visitor methods is a wrapper around an AST node, and it serves to provide access to the chain of ancestor objects (all the way back to the root of the AST) and scope information.</p>
<p>In general, <code>path.node</code> refers to the wrapped node, <code>path.parent.node</code> refers to the nearest <code>Node</code> ancestor, <code>path.parent.parent.node</code> to the grandparent, and so on.</p>
<p>Note that <code>path.node</code> may not be a direct property value of <code>path.parent.node</code>; for instance, it might be the case that <code>path.node</code> is an element of an array that is a direct child of the parent node: </p><div class="fragment"><div class="line">path.node === path.parent.node.elements[3]</div>
</div><!-- fragment --><p>in which case you should know that <code>path.parentPath</code> provides finer-grained access to the complete path of objects (not just the <code>Node</code> ones) from the root of the AST: </p><div class="fragment"><div class="line">// In reality, path.parent is the grandparent of path:</div>
<div class="line">path.parentPath.parentPath === path.parent</div>
<div class="line"> </div>
<div class="line">// The path.parentPath object wraps the elements array (note that we use</div>
<div class="line">// .value because the elements array is not a Node):</div>
<div class="line">path.parentPath.value === path.parent.node.elements</div>
<div class="line"> </div>
<div class="line">// The path.node object is the fourth element in that array:</div>
<div class="line">path.parentPath.value[3] === path.node</div>
<div class="line"> </div>
<div class="line">// Unlike path.node and path.value, which are synonyms because path.node</div>
<div class="line">// is a Node object, path.parentPath.node is distinct from</div>
<div class="line">// path.parentPath.value, because the elements array is not a</div>
<div class="line">// Node. Instead, path.parentPath.node refers to the closest ancestor</div>
<div class="line">// Node, which happens to be the same as path.parent.node:</div>
<div class="line">path.parentPath.node === path.parent.node</div>
<div class="line"> </div>
<div class="line">// The path is named for its index in the elements array:</div>
<div class="line">path.name === 3</div>
<div class="line"> </div>
<div class="line">// Likewise, path.parentPath is named for the property by which</div>
<div class="line">// path.parent.node refers to it:</div>
<div class="line">path.parentPath.name === &quot;elements&quot;</div>
<div class="line"> </div>
<div class="line">// Putting it all together, we can follow the chain of object references</div>
<div class="line">// from path.parent.node all the way to path.node by accessing each</div>
<div class="line">// property by name:</div>
<div class="line">path.parent.node[path.parentPath.name][path.name] === path.node</div>
</div><!-- fragment --><p>These <code>NodePath</code> objects are created during the traversal without modifying the AST nodes themselves, so it's not a problem if the same node appears more than once in the AST (like <code>Array.prototype.slice.call</code> in the example above), because it will be visited with a distict <code>NodePath</code> each time it appears.</p>
<p>Child <code>NodePath</code> objects are created lazily, by calling the <code>.get</code> method of a parent <code>NodePath</code> object: </p><div class="fragment"><div class="line">// If a NodePath object for the elements array has never been created</div>
<div class="line">// before, it will be created here and cached in the future:</div>
<div class="line">path.get(&quot;elements&quot;).get(3).value === path.value.elements[3]</div>
<div class="line"> </div>
<div class="line">// Alternatively, you can pass multiple property names to .get instead of</div>
<div class="line">// chaining multiple .get calls:</div>
<div class="line">path.get(&quot;elements&quot;, 0).value === path.value.elements[0]</div>
</div><!-- fragment --><p><code>NodePath</code> objects support a number of useful methods: </p><div class="fragment"><div class="line">// Replace one node with another node:</div>
<div class="line">var fifth = path.get(&quot;elements&quot;, 4);</div>
<div class="line">fifth.replace(newNode);</div>
<div class="line"> </div>
<div class="line">// Now do some stuff that might rearrange the list, and this replacement</div>
<div class="line">// remains safe:</div>
<div class="line">fifth.replace(newerNode);</div>
<div class="line"> </div>
<div class="line">// Replace the third element in an array with two new nodes:</div>
<div class="line">path.get(&quot;elements&quot;, 2).replace(</div>
<div class="line">    b.identifier(&quot;foo&quot;),</div>
<div class="line">    b.thisExpression()</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">// Remove a node and its parent if it would leave a redundant AST node:</div>
<div class="line">//e.g. var t = 1, y =2; removing the `t` and `y` declarators results in `var undefined`.</div>
<div class="line">path.prune(); //returns the closest parent `NodePath`.</div>
<div class="line"> </div>
<div class="line">// Remove a node from a list of nodes:</div>
<div class="line">path.get(&quot;elements&quot;, 3).replace();</div>
<div class="line"> </div>
<div class="line">// Add three new nodes to the beginning of a list of nodes:</div>
<div class="line">path.get(&quot;elements&quot;).unshift(a, b, c);</div>
<div class="line"> </div>
<div class="line">// Remove and return the first node in a list of nodes:</div>
<div class="line">path.get(&quot;elements&quot;).shift();</div>
<div class="line"> </div>
<div class="line">// Push two new nodes onto the end of a list of nodes:</div>
<div class="line">path.get(&quot;elements&quot;).push(d, e);</div>
<div class="line"> </div>
<div class="line">// Remove and return the last node in a list of nodes:</div>
<div class="line">path.get(&quot;elements&quot;).pop();</div>
<div class="line"> </div>
<div class="line">// Insert a new node before/after the seventh node in a list of nodes:</div>
<div class="line">var seventh = path.get(&quot;elements&quot;, 6);</div>
<div class="line">seventh.insertBefore(newNode);</div>
<div class="line">seventh.insertAfter(newNode);</div>
<div class="line"> </div>
<div class="line">// Insert a new element at index 5 in a list of nodes:</div>
<div class="line">path.get(&quot;elements&quot;).insertAt(5, newNode);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1373"></a>
Scope</h1>
<p>The object exposed as <code>path.scope</code> during AST traversals provides information about variable and function declarations in the scope that contains <code>path.node</code>. See <a href="lib/scope.js">scope.js</a> for its public interface, which currently includes <code>.isGlobal</code>, <code>.getGlobalScope()</code>, <code>.depth</code>, <code>.declares(name)</code>, <code>.lookup(name)</code>, and <code>.getBindings()</code>.</p>
<h1><a class="anchor" id="autotoc_md1374"></a>
Custom AST Node Types</h1>
<p>The <code>ast-types</code> module was designed to be extended. To that end, it provides a readable, declarative syntax for specifying new AST node types, based primarily upon the <code>require("ast-types").Type.def</code> function: </p><div class="fragment"><div class="line">var types = require(&quot;ast-types&quot;);</div>
<div class="line">var def = types.Type.def;</div>
<div class="line">var string = types.builtInTypes.string;</div>
<div class="line">var b = types.builders;</div>
<div class="line"> </div>
<div class="line">// Suppose you need a named File type to wrap your Programs.</div>
<div class="line">def(&quot;File&quot;)</div>
<div class="line">    .bases(&quot;Node&quot;)</div>
<div class="line">    .build(&quot;name&quot;, &quot;program&quot;)</div>
<div class="line">    .field(&quot;name&quot;, string)</div>
<div class="line">    .field(&quot;program&quot;, def(&quot;Program&quot;));</div>
<div class="line"> </div>
<div class="line">// Prevent further modifications to the File type (and any other</div>
<div class="line">// types newly introduced by def(...)).</div>
<div class="line">types.finalize();</div>
<div class="line"> </div>
<div class="line">// The b.file builder function is now available. It expects two</div>
<div class="line">// arguments, as named by .build(&quot;name&quot;, &quot;program&quot;) above.</div>
<div class="line">var main = b.file(&quot;main.js&quot;, b.program([</div>
<div class="line">    // Pointless program contents included for extra color.</div>
<div class="line">    b.functionDeclaration(b.identifier(&quot;succ&quot;), [</div>
<div class="line">        b.identifier(&quot;x&quot;)</div>
<div class="line">    ], b.blockStatement([</div>
<div class="line">        b.returnStatement(</div>
<div class="line">            b.binaryExpression(</div>
<div class="line">                &quot;+&quot;, b.identifier(&quot;x&quot;), b.literal(1)</div>
<div class="line">            )</div>
<div class="line">        )</div>
<div class="line">    ]))</div>
<div class="line">]));</div>
<div class="line"> </div>
<div class="line">assert.strictEqual(main.name, &quot;main.js&quot;);</div>
<div class="line">assert.strictEqual(main.program.body[0].params[0].name, &quot;x&quot;);</div>
<div class="line">// etc.</div>
<div class="line"> </div>
<div class="line">// If you pass the wrong type of arguments, or fail to pass enough</div>
<div class="line">// arguments, an AssertionError will be thrown.</div>
<div class="line"> </div>
<div class="line">b.file(b.blockStatement([]));</div>
<div class="line">// ==&gt; AssertionError: {&quot;body&quot;:[],&quot;type&quot;:&quot;BlockStatement&quot;,&quot;loc&quot;:null} does not match type string</div>
<div class="line"> </div>
<div class="line">b.file(&quot;lib/types.js&quot;, b.thisExpression());</div>
<div class="line">// ==&gt; AssertionError: {&quot;type&quot;:&quot;ThisExpression&quot;,&quot;loc&quot;:null} does not match type Program</div>
</div><!-- fragment --><p>The <code>def</code> syntax is used to define all the default AST node types found in <a href="def/core.js">core.js</a>, <a href="def/e4x.js">e4x.js</a>, <a href="def/es6.js">es6.js</a>, <a href="def/es7.js">es7.js</a>, <a href="def/flow.js">flow.js</a>, and <a href="def/jsx.js">jsx.js</a>, so you have no shortage of examples to learn from. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
