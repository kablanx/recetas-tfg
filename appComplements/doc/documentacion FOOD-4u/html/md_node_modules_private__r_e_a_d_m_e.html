<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Food4uDoc: private &lt;a href=&quot;https://travis-ci.org/benjamn/private&quot;&gt;&lt;img src=&quot;https://travis-ci.org/benjamn/private.png?branch=master&quot; alt=&quot;Build Status&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://greenkeeper.io/&quot;&gt;&lt;img src=&quot;https://badges.greenkeeper.io/benjamn/private.svg&quot; alt=&quot;Greenkeeper badge&quot;/&gt;&lt;/a&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="1_efuIMAmjzSpn9p7WalC6fA.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Food4uDoc
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_node_modules_private__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">private <a href="https://travis-ci.org/benjamn/private"><img src="https://travis-ci.org/benjamn/private.png?branch=master" alt="Build Status" class="inline"/></a> <a href="https://greenkeeper.io/"><object type="image/svg+xml" data="https://badges.greenkeeper.io/benjamn/private.svg" style="pointer-events: none;">Greenkeeper badge</object></a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A general-purpose utility for associating truly private state with any JavaScript object.</p>
<h1><a class="anchor" id="autotoc_md15967"></a>
Installation</h1>
<p>From NPM: </p><pre class="fragment">npm install private
</pre><p>From GitHub: </p><pre class="fragment">cd path/to/node_modules
git clone git://github.com/benjamn/private.git
cd private
npm install .
</pre><h1><a class="anchor" id="autotoc_md15968"></a>
Usage</h1>
<p><b>Get or create a secret object associated with any (non-frozen) object:</b> </p><div class="fragment"><div class="line">var getSecret = require(&quot;private&quot;).makeAccessor();</div>
<div class="line">var obj = Object.create(null); // any kind of object works</div>
<div class="line">getSecret(obj).totallySafeProperty = &quot;p455w0rd&quot;;</div>
<div class="line"> </div>
<div class="line">console.log(Object.keys(obj)); // []</div>
<div class="line">console.log(Object.getOwnPropertyNames(obj)); // []</div>
<div class="line">console.log(getSecret(obj)); // { totallySafeProperty: &quot;p455w0rd&quot; }</div>
</div><!-- fragment --><p>Now, only code that has a reference to both <code>getSecret</code> and <code>obj</code> can possibly access <code>.totallySafeProperty</code>.</p>
<p><em>Importantly, no global references to the secret object are retained by the <code>private</code> package, so as soon as <code>obj</code> gets garbage collected, the secret will be reclaimed as well. In other words, you don't have to worry about memory leaks.</em></p>
<p><b>Create a unique property name that cannot be enumerated or guessed:</b> </p><div class="fragment"><div class="line">var secretKey = require(&quot;private&quot;).makeUniqueKey();</div>
<div class="line">var obj = Object.create(null); // any kind of object works</div>
<div class="line"> </div>
<div class="line">Object.defineProperty(obj, secretKey, {</div>
<div class="line">  value: { totallySafeProperty: &quot;p455w0rd&quot; },</div>
<div class="line">  enumerable: false // optional; non-enumerability is the default</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">Object.defineProperty(obj, &quot;nonEnumerableProperty&quot;, {</div>
<div class="line">  value: &quot;anyone can guess my name&quot;,</div>
<div class="line">  enumerable: false</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">console.log(obj[secretKey].totallySafeProperty); // p455w0rd</div>
<div class="line">console.log(obj.nonEnumerableProperty); // &quot;anyone can guess my name&quot;</div>
<div class="line">console.log(Object.keys(obj)); // []</div>
<div class="line">console.log(Object.getOwnPropertyNames(obj)); // [&quot;nonEnumerableProperty&quot;]</div>
<div class="line"> </div>
<div class="line">for (var key in obj) {</div>
<div class="line">  console.log(key); // never called</div>
<div class="line">}</div>
</div><!-- fragment --><p>Because these keys are non-enumerable, you can't discover them using a <code>for</code>-<code>in</code> loop. Because <code>secretKey</code> is a long string of random characters, you would have a lot of trouble guessing it. And because the <code>private</code> module wraps <code>Object.getOwnPropertyNames</code> to exclude the keys it generates, you can't even use that interface to discover it.</p>
<p>Unless you have access to the value of the <code>secretKey</code> property name, there is no way to access the value associated with it. So your only responsibility as secret-keeper is to avoid handing out the value of <code>secretKey</code> to untrusted code.</p>
<p>Think of this style as a home-grown version of the first style. Note, however, that it requires a full implementation of ES5's <code>Object.defineProperty</code> method in order to make any safety guarantees, whereas the first example will provide safety even in environments that do not support <code>Object.defineProperty</code>.</p>
<h1><a class="anchor" id="autotoc_md15969"></a>
Rationale</h1>
<p>In JavaScript, the only data that are truly private are local variables whose values do not <em>leak</em> from the scope in which they were defined.</p>
<p>This notion of <em>closure privacy</em> is powerful, and it readily provides some of the benefits of traditional data privacy, a la Java or C++: </p><div class="fragment"><div class="line">function MyClass(secret) {</div>
<div class="line">    this.increment = function() {</div>
<div class="line">        return ++secret;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">var mc = new MyClass(3);</div>
<div class="line">console.log(mc.increment()); // 4</div>
</div><!-- fragment --><p>You can learn something about <code>secret</code> by calling <code>.increment()</code>, and you can increase its value by one as many times as you like, but you can never decrease its value, because it is completely inaccessible except through the <code>.increment</code> method. And if the <code>.increment</code> method were not available, it would be as if no <code>secret</code> variable had ever been declared, as far as you could tell.</p>
<p>This style breaks down as soon as you want to inherit methods from the prototype of a class: </p><div class="fragment"><div class="line">function MyClass(secret) {</div>
<div class="line">    this.secret = secret;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">MyClass.prototype.increment = function() {</div>
<div class="line">    return ++this.secret;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The only way to communicate between the <code>MyClass</code> constructor and the <code>.increment</code> method in this example is to manipulate shared properties of <code>this</code>. Unfortunately <code>this.secret</code> is now exposed to unlicensed modification: </p><div class="fragment"><div class="line">var mc = new MyClass(6);</div>
<div class="line">console.log(mc.increment()); // 7</div>
<div class="line">mc.secret -= Infinity;</div>
<div class="line">console.log(mc.increment()); // -Infinity</div>
<div class="line">mc.secret = &quot;Go home JavaScript, you&#39;re drunk.&quot;;</div>
<div class="line">mc.increment(); // NaN</div>
</div><!-- fragment --><p>Another problem with closure privacy is that it only lends itself to per-instance privacy, whereas the <code>private</code> keyword in most object-oriented languages indicates that the data member in question is visible to all instances of the same class.</p>
<p>Suppose you have a <code>Node</code> class with a notion of parents and children: </p><div class="fragment"><div class="line">function Node() {</div>
<div class="line">    var parent;</div>
<div class="line">    var children = [];</div>
<div class="line"> </div>
<div class="line">    this.getParent = function() {</div>
<div class="line">        return parent;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    this.appendChild = function(child) {</div>
<div class="line">        children.push(child);</div>
<div class="line">        child.parent = this; // Can this be made to work?</div>
<div class="line">    };</div>
<div class="line">}</div>
</div><!-- fragment --><p>The desire here is to allow other <code>Node</code> objects to manipulate the value returned by <code>.getParent()</code>, but otherwise disallow any modification of the <code>parent</code> variable. You could expose a <code>.setParent</code> function, but then anyone could call it, and you might as well give up on the getter/setter pattern.</p>
<p>This module solves both of these problems.</p>
<h1><a class="anchor" id="autotoc_md15970"></a>
Usage</h1>
<p>Let's revisit the <code>Node</code> example from above: </p><div class="fragment"><div class="line">var p = require(&quot;private&quot;).makeAccessor();</div>
<div class="line"> </div>
<div class="line">function Node() {</div>
<div class="line">    var privates = p(this);</div>
<div class="line">    var children = [];</div>
<div class="line"> </div>
<div class="line">    this.getParent = function() {</div>
<div class="line">        return privates.parent;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    this.appendChild = function(child) {</div>
<div class="line">        children.push(child);</div>
<div class="line">        var cp = p(child);</div>
<div class="line">        if (cp.parent)</div>
<div class="line">            cp.parent.removeChild(child);</div>
<div class="line">        cp.parent = this;</div>
<div class="line">        return child;</div>
<div class="line">    };</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, in order to access the private data of a <code>Node</code> object, you need to have access to the unique <code>p</code> function that is being used here. This is already an improvement over the previous example, because it allows restricted access by other <code>Node</code> instances, but can it help with the <code>Node.prototype</code> problem too?</p>
<p>Yes it can! </p><div class="fragment"><div class="line">var p = require(&quot;private&quot;).makeAccessor();</div>
<div class="line"> </div>
<div class="line">function Node() {</div>
<div class="line">    p(this).children = [];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">var Np = Node.prototype;</div>
<div class="line"> </div>
<div class="line">Np.getParent = function() {</div>
<div class="line">    return p(this).parent;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Np.appendChild = function(child) {</div>
<div class="line">    p(this).children.push(child);</div>
<div class="line">    var cp = p(child);</div>
<div class="line">    if (cp.parent)</div>
<div class="line">        cp.parent.removeChild(child);</div>
<div class="line">    cp.parent = this;</div>
<div class="line">    return child;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Because <code>p</code> is in scope not only within the <code>Node</code> constructor but also within <code>Node</code> methods, we can finally avoid redefining methods every time the <code>Node</code> constructor is called.</p>
<p>Now, you might be wondering how you can restrict access to <code>p</code> so that no untrusted code is able to call it. The answer is to use your favorite module pattern, be it CommonJS, AMD <code>define</code>, or even the old Immediately-Invoked Function Expression: </p><div class="fragment"><div class="line">var Node = (function() {</div>
<div class="line">    var p = require(&quot;private&quot;).makeAccessor();</div>
<div class="line"> </div>
<div class="line">    function Node() {</div>
<div class="line">        p(this).children = [];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    var Np = Node.prototype;</div>
<div class="line"> </div>
<div class="line">    Np.getParent = function() {</div>
<div class="line">        return p(this).parent;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    Np.appendChild = function(child) {</div>
<div class="line">        p(this).children.push(child);</div>
<div class="line">        var cp = p(child);</div>
<div class="line">        if (cp.parent)</div>
<div class="line">            cp.parent.removeChild(child);</div>
<div class="line">        cp.parent = this;</div>
<div class="line">        return child;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    return Node;</div>
<div class="line">}());</div>
<div class="line"> </div>
<div class="line">var parent = new Node;</div>
<div class="line">var child = new Node;</div>
<div class="line">parent.appendChild(child);</div>
<div class="line">assert.strictEqual(child.getParent(), parent);</div>
</div><!-- fragment --><p>Because this version of <code>p</code> never leaks from the enclosing function scope, only <code>Node</code> objects have access to it.</p>
<p>So, you see, the claim I made at the beginning of this README remains true:</p>
<blockquote class="doxtable">
<p>In JavaScript, the only data that are truly private are local variables whose values do not <em>leak</em> from the scope in which they were defined. </p>
</blockquote>
<p>It just so happens that closure privacy is sufficient to implement a privacy model similar to that provided by other languages. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
